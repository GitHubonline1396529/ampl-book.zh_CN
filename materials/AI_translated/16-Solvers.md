
# 14

# 与求解器的交互

本章更详细地描述了 AMPL 用于控制和调整发送给求解器的问题，以及提取和解释求解器返回信息的各种机制。其中最重要的一个是 presolve 阶段，它执行简化和变换，通常可以减少求解器实际看到的问题规模；这是 14.1 节的主题。模型组件上的后缀允许与高级求解器交换各种有用信息，如 14.2 和 14.3 节所述。命名问题使 AMPL 脚本能够在单个模型内管理多个问题实例，并执行在截然不同的模型之间交替的迭代过程，如 14.4 和 14.5 节所示。

# 14.1 Presolve 阶段

AMPL 的 presolve 阶段尝试在问题实例生成之后、发送给求解器之前对其进行简化。当执行 `solve` 命令或生成实例的其他命令时，它会自动运行，如 A.18.1 节所述。在返回解之后，presolve 所做的任何简化都会被逆转，因此你可以从原始问题的角度查看解。因此，presolve 通常在后台静默进行。只有当你将选项 `show_stats` 从默认值 0 更改为 1 时，才会报告其效果：

```
ampl: model steelT.mod; data steelT.dat;
ampl: option show_stats 1;
ampl: solve;
Presolve eliminates 2 constraints and 2 variables.
Adjusted problem:
24 variables, all linear
12 constraints, all linear; 38 nonzeros
1 linear objective; 24 nonzeros.
MINOS 5.5: optimal solution found.
15 iterations, objective 515033
```

你可以通过测试确定哪些变量和约束被 presolve 消除，如 14.2 节所述，查看哪些变量或约束的状态为 `pre`：

```
ampl: print {j in 1.._nvars:
       ampl? _var[j].status = "pre"}: _varname[j];
Inv['bands', 0]
Inv['coils', 0]
ampl: print {i in 1.._ncons:
       ampl? _con[i].status = "pre"}: _conname[i];
Init_Inv['bands']
Init_Inv['coils']
```

然后你可以使用 `show` 和 `display` 来检查被消除的组件。

在本节中，我们介绍 presolve 阶段的操作以及从 AMPL 控制它的选项。接着我们解释当 presolve 检测到不存在可行解时会发生什么。然而，我们不会试图解释整个 presolve 算法；本章末尾的参考文献之一包含完整的描述。

# presolve 阶段的活动

为了生成一个问题实例，AMPL 首先为每个变量分配其 var 声明中指定的边界，或者在未给出下界或上界时分配特殊边界 $-\infty$ 和 $\infty$。然后 presolve 阶段尝试使用这些边界以及线性约束来推导出仍然满足问题所有可行解的更紧边界。同时，presolve 尝试使用更紧的边界来检测可以固定的变量和可以删除的约束。

Presolve 最初寻找只有一个变量的约束。这类等式固定一个变量，然后可以从问题中删除该变量。不等式为变量指定一个边界，该边界可以合并到现有边界中。在上面所示的 steelT.mod（图 4-4）示例中，presolve 消除了从声明 `subject to Initial {p in PROD}: Inv[p,0] = inv0[p];` 生成的两个约束，以及由这些约束固定的两个变量。

Presolve 继续寻找可以通过当前边界证明冗余的约束。从 dietu.mod（图 5-1）中消除的约束提供了一个示例：

ampl: model dietu.mod; data dietu.dat;  
ampl: option show_state 1;  
ampl: solve;  
预处理消除了 3 个约束。  
调整后的问题：  
8 个变量，均为线性  
5 个约束，均为线性；39 个非零元素  
1 个线性目标函数；8 个非零元素。  
MINOS 5.5：找到最优解。  
5 次迭代，目标函数值 74.27382022  

ampl: print {i in 1.._ncons:  
ampl? _con[i].status = "pre"}: _conname[i];  
Diet_Min['B1']  
Diet_Min['B2']  
Diet_Max['A']  

进一步调查发现，约束 Diet_Min['B1'] 是冗余的，因为它是由以下语句生成的：  
subject to Diet_Min {i in MINREQ}:  
sum {j in FOOD} amt[i,j] * Buy[j] >= n_min[i];  

而数据中 n_min['B1'] 等于零。显然，任何变量组合都满足该条件，因为所有变量都有非负下界。一个不那么平凡的例子是 Diet_Max['A']，它由以下语句生成：  
subject to Diet_Max {i in MAXREQ}:  
sum {j in FOOD} amt[i,j] * Buy[j] <= n_max[i];  

通过将每个变量设置为其在该约束左侧的上界，我们可以得到任何解可能提供的该营养素总量的上界。特别地，对于营养素 A：  

ampl: display sum {j in FOOD} amt['A',j] * f_max[j];  
sum{j in FOOD} amt['A',j]*f_max[j] = 2860  

由于数据文件中 n_max['A'] 为 20000，因此这是另一个不可能被变量违反的约束。  

完成这些测试后，预处理的第一阶段就结束了。其余部分包括对问题进行一系列遍历，每次尝试从当前边界和线性约束中推导出更紧的变量边界。我们在此仅展示一个来自 multi.mod 和 multi.dat（图 4-1 和 4-2）生成的问题实例的结果示例：

ampl: model multi.mod;  
ampl: data multi.dat;  
ampl: option show_stats 1;  
ampl: solve;  
预处理消除了 7 个约束和 3 个变量。  
调整后的问题：  
60 个变量，均为线性  
44 个约束，均为线性；165 个非零元素  
1 个线性目标函数；60 个非零元素。  
MINOS 5.5：找到最优解。  
41 次迭代，目标函数值 199500  

ampl: print {j in 1.._nvars:  
ampl? _var.status[j] = "pre"}: _varname[j];  
Trans['GARY', 'LAN', 'plate']  
Trans['CLEV', 'LAN', 'plate']  
Trans['PITT', 'LAN', 'plate']  

ampl: print {i in 1.._ncons:  
ampl? _con[i].status = "pre"}: _conname[i];  
Demand['LAN','plate']  
Multi['GARY','LAN']  
Multi['GARY','WIN']  
Multi['CLEV','LAN']  
Multi['CLEV','WIN']  
Multi['PITT','LAN']  
Multi['PITT','WIN']  

我们可以通过展开被消除的需求约束来了解一些简化的原因：  

ampl: expand Demand['LAN','plate'];  
subject to Demand['LAN','plate']:  
Trans['GARY','LAN','plate'] + Trans['CLEV','LAN','plate'] +  
Trans['PITT','LAN','plate'] = 0;

因为在数据中 demand['LAN','plate'] 为零，该 约束 (constraint) 强制三个非负 变量 (variable) 的和为零，因此在任何解中这三个变量的上限都必须为零。由于它们已经有下限零，因此可以固定它们并删除该约束。其他被删除的约束都类似如下形式：

ampl: expand Multi['GARY','LAN'];
subject to Multi['GARY','LAN']:
Trans['GARY','LAN','bands'] + Trans['GARY','LAN','coils'] +
Trans['GARY','LAN','plate'] <= 625;

这些约束可以被删除，因为左侧变量的上限之和小于 625。然而，这些变量在问题中最初并未给定上限。相反，这些上限是由 presolve 的第二部分推导出来的。对于这个简单问题，不难看出推导出的界限是如何产生的：沿任何一条链接运输的任何产品的数量不能超过该产品在链接目的地的需求量。对于目的地 LAN 和 WIN，三种产品的总需求小于从任何起点出发的运输总量上限 625，因此总运输量约束是多余的。

# 控制 presolve 的效果

对于更复杂的问题，presolve 对变量和约束的删除可能不容易解释，但它们可能代表问题的相当大一部分。因此，解决问题实例所需的时间和内存可能会大幅减少。在极少数情况下，当存在多个最优解时，presolve 也可能显著影响变量的最优值，或干扰求解器软件中内置的其他预处理例程。要完全关闭 presolve，请将选项 presolve 设置为 0；要仅关闭第二部分，请将其设置为 1。该选项的更高值表示 presolve 第二部分中执行的最大遍数；默认值为 10。

在 presolve 之后，AMPL 会保存两组变量的下限和上限：一组反映由 presolve 删除的约束所隐含的界限收紧，另一组反映由 presolve 无法删除的约束进一步推导出的界限收紧。使用任一组界限，问题都有相同的解，但根据所使用的优化方法和问题的具体情况，整体求解 时间 (time) 可能会因使用其中一组界限而更低。

对于连续变量，通常 AMPL 会向求解器传递第一组界限，但您可以通过将选项 var_bounds 从默认值 1 更改为 2 来指示它传递第二组界限。当应用活动集方法（如 单纯形法 (simplex method)）时，第二组界限往往会产生更多退化变量，从而导致更多退化迭代，可能阻碍求解进程。

对于整数变量，AMPL 会将任何小数形式的下界 (lower bound) 向上取整为下一个更高的整数，而将任何小数形式的上界 (upper bound) 向下取整为下一个更低的整数。然而，由于有限精度计算的不准确性，某个边界值的计算结果可能与整数值略有差异。例如，一个本应为 7 的下界，可能会被计算为 7.00000000001，在这种情况下，你并不希望该边界被向上取整为 8！为了应对这种可能性，AMPL 在取整之前，会从每个下界中减去选项 presolve_inteps 的值，并将其加到每个上界中。如果将该设置增大到选项 presolve_intepsmax 的值会对任何变量的取整边界产生影响，AMPL 将发出警告。presolve_inteps 和 presolve_intepsmax 的默认值分别为 1.0e-6 和 1.0e-5。

你可以通过后缀 .lb1 和 .ub1 查看第一组 presolve 边界，通过 .lb2 和 .ub2 查看第二组边界。原始边界（只有在关闭 presolve 时才会发送给求解器）表示为 .lb0 和 .ub0。后缀 .lb 和 .ub 则根据当前的 presolve 和 var_bounds 选项值，给出当前要传递给求解器的边界值。

# 在 presolve 中检测不可行性

如果 presolve 确定某个变量的下界大于其上界，则不存在满足所有边界和其他约束的解，此时将打印一条错误信息。例如，如果我们本意是将 market["bands"] 改为 5000，却错误地改成了 500，steel3.mod（图 1-5a）将会发生如下情况：

```ampl
ampl: model steel3.mod;
ampl: data steel3.dat;
ampl: let market["bands"] := 500;
ampl: solve;
inconsistent bounds for var Make['bands']:
    lower bound = 1000
    upper bound = 500;
    difference = 500
```

这是一个简单的情况，因为变量 Make["bands"] 的上界明显被降低到了下界之下。presolve 更复杂的测试还可以发现并非由单个变量引起的不可行性。例如，考虑模型中的如下约束：

subject to Time: sum {p in PROD} 1/rate[p] * Make[p] <= avail;

如果我们把 avail 的值减少到 13 小时，presolve 会推断出该约束不可能被满足：

```ampl
ampl: let market["bands"] := 5000;
ampl: let avail := 13;
ampl: solve;
presolve: 约束 Time 无法满足：
    body <= 13 不能 >= 13.2589；
    差值 = -0.258929
```

约束 Time 的“主体 (body)”是 sum {p in PROD} 1/rate[p] * Make[p]，即包含变量的部分（见第 12.5 节）。因此，在我们设定的 avail 值下，该约束对主体表达式的值施加了 13 的上界。另一方面，如果我们将主体表达式中的每个变量都设为其下界，则可以得到在任何可行解中主体表达式的下界。

```ampl
ampl: display sum {p in PROD} 1/rate[p] * Make[p].lb2;
sum[p in PROD] 1/rate[p] * (Make[p].lb2) = 13.2589
```

因此，预处理 (presolve) 报告主体 $< = 13$ 不能 $> = 13.2589$，即表示主体的上界与下界冲突，意味着没有任何解能满足所有问题的边界和约束。

预处理报告了约束 Time 的两个边界之间的差值为 -0.258929（保留六位小数）。因此，在这种情况下我们可以推测，大约 13.258929 是使问题存在可行解的最小 avail 值，我们可以通过实验验证这一点：

ampl: let avail := 13.258929;  
ampl: solve;  
MINDS 5.5: 找到最优解。  
0 次迭代，目标函数值 61750.00214  

然而，如果我们把 avail 稍微调低一点，又会得到不可行的信息：

ampl: let avail := 13.258928;  
ampl: solve;  
presolve: 约束 Time 无法满足：  
body <= 13.2589 不能 >= 13.2589;  
差值 = -5.71429e-07  
设置 $presolve_eps >= 6.86e-07$ 可能会有帮助。

虽然这里的下界与上界在六位小数内相同，但在完整精度下它大于上界，正如差值为负所表明的那样。

在这种情况下第二次输入 solve 命令会让 AMPL 忽略预处理的结果，并将看似矛盾的推导边界发送给求解器：

ampl: solve;  
MINOS 5.5: 找到最优解。  
0 次迭代，目标函数值 61749.99714  
ampl: option display_precision 10;  
ampl: display commit, Make;

:     commit       Make  
bands   1000     999.9998857  
coils    500     500  
plate    750     750  

MINOS 声称找到了一个最优解，尽管 Make["bands"] 略小于其下界 commit["bands"]！这里 MINOS 应用了内部容差，允许忽略小的不可行性；AMPL/MINOS 文档解释了该容差的工作原理以及如何更改它。每个求解器都以自己的方式应用可行性容差，因此不同求解器给出不同结果并不令人意外：

ampl: option solver cplex;  
ampl: option send_statuses 0;  
ampl: solve;  
CPLEX 8.0.0: 列 'xl' 的界不可行。  
不可行问题。  
1 次对偶单纯形法迭代（第 I 阶段 0 次）

在这里，CPLEX 应用了自身的预处理程序，并检测到了 AMPL 所发现的相同不可行性。（你可能会看到一些关于名为 dumbdd 的“后缀”的附加行；这涉及一个无界方向，你可以通过 AMPL 的求解器定义的后缀功能在第 14.3 节中描述的方法获取。）

当某个 变量 (variable) 或 约束体 (constraint body) 的隐含 下界 (lower bound) 和 上界 (upper bound) 相等时（至少在实际应用中如此），就会出现这种情况。由于计算中的不精确性，下界可能略微大于上界，导致 AMPL 的 预处理 (presolve) 报告问题不可行。为避免这种困难，你可以将选项 presolve_eps 从默认值 0 重置为某个小的正值。当下界与上界之间的差异小于该值时，这些差异将被忽略。如果将当前 presolve_eps 值增加到不超过 presolve_epsmax 的值会改变 presolve 对问题的处理方式，则 presolve 会显示一条相关消息，例如：

Setting \$presolve_eps >= 6.86e-07 might help.

如上例所示。选项 presolve_eps 的默认值为零，presolve_epsmax 的默认值为 1.0e-5。

另一种相关的情况是，计算中的不精确性导致某个变量或约束体的隐含下界略低于其隐含上界。此时虽然未检测到不可行性，但近乎相等的边界可能使 求解器 (solver) 的工作变得异常困难。因此，当变量或约束体的上界减去下界为正值但小于选项 presolve_fixeps 的值时，该变量或约束体将被固定在两个边界的平均值上。如果将 presolve_fixeps 的值增加到最多不超过 presolve_fixepsmax 的值会改变 presolve 的结果，则会显示一条相关消息。

预处理 (presolve) 显示的独立消息数量被限制为 presolve_warnings 的值，默认为 5。将选项 show_stats 增加到 2 可能会显示一些关于 presolve 运行的额外信息，包括对结果产生影响的迭代次数，以及 presolve_eps 和 presolve_inteps 需要增加或减少到什么值才能产生影响。

# 14.2 从 求解器 (solver) 中获取结果

除了解和相关的数值外，获取 solve 命令结果的某些符号信息也很有用。例如，在 AMPL 命令脚本中，你可能希望测试最近一次 solve 是否遇到了无界或不可行的问题。或者，在使用 单纯形法 (simplex method) 解决一个 线性规划 (linear program) 后，你可能希望利用 最优基划分 (optimal basis partition) 为解决相关问题提供良好的起点。AMPL-求解器接口允许求解器返回这些及相关类型的状态信息，供你检查和使用。

# 求解结果

求解器完成其工作是因为它已识别出一个 最优解 (optimal solution) 或遇到了某些其他终止条件。除了变量的值之外，求解器还可以设置两个内置的 AMPL 参数和一个 AMPL 选项，以提供有关优化过程结果的信息：

```python
ampl: model diet.mod;
ampl: data diet2.dat;
ampl: display solve_result_num, solve_result;
solve_result_num = -1
solve_result = '?'
ampl: solve;
MINOS 5.5: 不可行问题。
9 次迭代
ampl: display solve_result_num, solve_result;
solve_result_num = 200
solve_result = infeasible
```

ampl: option solve_result_table;
option solve_result_table '\
0 solved\
100 solved?\
200 infeasible\
300 unbounded\
400 limit\
500 failure\
';

在 AMPL 会话开始时，`solve_result_num` 为 -1，`solve_result` 为 '?'。然而，每个 `solve` 命令都会重置这些参数，以便它们描述求解器运行结束时的状态：`solve_result_num` 用数字表示，`solve_result` 用字符串表示。`solve_result_table` 选项列出了可能的组合，其解释如下：

`solve_result` 值范围 数字 字符串解释  
0-99 solved 找到最优解  
100-199 solved? 指示最优解，但可能有错误  
200-299 infeasible 约束无法满足  
300-399 unbounded 目标函数可以无限制地改善  
400-499 limit 被设定的限制（如迭代次数）停止  
500-599 failure 被求解器中的错误条件停止  

通常，这种状态信息用于脚本中，可以测试它以区分必须以不同方式处理的情况。例如，图 14-1 描述了一个 AMPL 脚本，用于饮食模型，该脚本读取营养成分的名称（从标准输入读取，使用文件名 -，如第 9.5 节所述）、饮食中该营养成分的初始上限以及减少上限的步长。循环持续运行，直到上限减少到问题变得不可行的点，此时打印适当的消息和之前找到的解表。一次典型的运行如下所示：

```
ampl: commands diet.run; <1>
ampl? NA <1>
ampl? 60000 <1>
ampl? 3000
-------------------------------- infeasible at 48000 --------------------------------
:     N_obj      N_dual      :=
51000  115.625    -0.0021977
54000  109.42     -0.00178981
57000  104.05     -0.00178981
60000  101.013     7.03757e-19
;
```

这里钠（数据中的 NA）的上限从 60000 以 3000 为步长逐步减少，直到问题在上限为 48000 时变得不可行。

`diet.run` 中测试不可行性的关键语句是：

```ampl
model diet.mod;
data diet2.dat;
param N symbolic in NUTR;
param nstart > 0;
param nstep > 0;
read N, nstart, nstep <- ; # 交互式读取数据
set N_MAX default {};
param N_obj {N_MAX};
param N_dual {N_MAX};
option solver_msg 0;
for {i in nstart..0 by -nstep} {
    let n_max[N] := i;
    solve;
    if solve_result = "infeasible" then {
        printf "------------------------------------------------------------------------------------------------------------------------";
        break;
    }
    let N_MAX := N_MAX union {i};
    let N_obj[i] := Total_Cost;
    let N_dual[i] := Diet[N].dual;
}
display N_obj, N_dual;
```

图 14-1：带有不可行性测试的敏感性分析 (diet.run)。

if solve_result $=$ "infeasible" then { printf "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------......" break; }

`if` 条件也可以等价地写成 $200 \leq$ `solve_result_num` $< 300$。通常你会希望避免使用这种替代写法，因为它会让脚本变得晦涩难懂。然而，在需要对不同的求解器 (solver) 终止条件进行精细区分时，这种方式偶尔会很有用。例如，以下是 CPLEX 求解器针对不同最优性条件设置的一些值：

`solve_result_num` 终止时的消息  
0 最优解  
1 原始问题具有无界最优面  
2 最优整数解  
3 在 mipgap 或 absmipgap 范围内的最优整数解  

在所有这些情况下，`solve_result` 的值都是 `"solved"`，但如果你需要在它们之间进行区分，可以测试 `solve_result_num`。`solve_result_num` 的解释完全取决于求解器；你必须查阅特定求解器的文档，以了解它返回哪些值以及它们的含义。

AMPL 的求解器接口会显示几行类似以下内容的信息：

```
MINOS 5.5: infeasible problem. 9 iterations
```

用于总结已完成的求解过程。如果你运行的脚本频繁执行 `solve` 命令，这些消息可能会产生大量输出；你可以通过将选项 `solver_msg` 设置为 0 来抑制这些消息的显示。内置的符号参数 `solve_message` 始终包含最近一次求解器返回的消息，即使消息显示已被关闭。你可以显示此参数以验证其值：

```pythonmpl
display solve_message;
solve_message = 'MINOS 5.5: infeasible problem. 9 iterations'
```

由于 `solve_message` 是一个符号参数，其值是一个字符串。它在脚本中最有用，你可以使用字符串函数（第 13.7 节）来测试消息中是否包含最优性或其他结果的指示信息。

例如，`diet.run` 中的测试也可以写成：

```pythonmpl
if match(solve_message, "infeasible") > 0 then {
```

然而，由于返回消息在不同求解器之间有所不同，因此在大多数情况下，对 `solve_result` 的测试会更简单且更少依赖于特定求解器。

只有在 AMPL 调用求解器成功的情况下，才能返回如上所述的求解结果。调用可能失败，因为操作系统无法找到或执行指定的求解器，或者由于某些低级错误导致求解器无法尝试或完成优化。典型原因包括拼写错误的求解器名称、求解器安装或授权不当、资源不足，以及求解器进程因执行错误（“核心转储”）或键盘中断（“break”）而终止。在这些情况下，`solve` 后面的错误消息是由操作系统而不是求解器生成的，您可能需要咨询系统专家来追踪问题。例如，类似 `can't open at 8871.nl` 的消息通常表示 AMPL 无法写入临时文件；它可能试图写入已满的磁盘，或写入您没有写入权限的目录（文件夹）。（临时文件的目录在选项 `TMPDIR` 中指定。）

内置参数 `solve_exitcode` 记录了最近一次求解器调用的成功或失败。初始值为 -1，当调用成功时重置为 0，否则重置为某个与系统相关的非零值：

```python
ampl: reset;
ampl: display solve_exitcode;
solve_exitcode = -1

ampl: model diet.mod;
ampl: data diet2.dat;
ampl: option solver xplex;
ampl: solve;
Cannot invoke xplex: No such file or directory
```

ampl: display solve_exitcode;  
solve_exitcode = 1024  

ampl: display solve_result, solve_result_num;  
solve_result = '?'  
solve_result_num = -1  

在这里，由于求解器名称拼写错误 xplex，调用失败，反映在正值的 solve_exitcode 值中。状态参数 solve_result 和 solve_result_num 也被重置为其初始值 '?' 和 -1。

如果 solve_exitcode 超过选项 solve_exitcode_max 中的值，则 AMPL 会中止当前正在执行的复合语句（include、commands、repeat、for、if）。solve_exitcode_max 的默认值为 0，因此当求解器调用失败时，AMPL 通常会中止复合语句。将 solve_exitcode_max 设置为较高值的脚本可以测试 solve_exitcode 的值，但通常其解释在不同操作系统或求解器之间并不一致。

# 目标函数和问题的求解器状态

有时为了方便起见，希望能够引用在特定目标函数最近一次优化时获得的求解结果。为此，AMPL 为每个内置求解结果参数关联了一个“状态”后缀：

内置参数 后缀  
solve_result .result  
solve_result_num .result_num  
solve_message .message  
solve_exitcode .exitcode  

附加在目标函数名称后，该后缀表示在该目标函数为当前目标的最近一次求解中，相应内置参数的值。

作为示例，我们再次考虑第 8.3 节中为指派模型定义的多个目标函数：

最小化 总成本：sum {i in ORIG, j in DEST} cost[i,j] * Trans[i,j]；  
最小化 Pref_of {i in ORIG}；sum {j in DEST} cost[i,j] * Trans[i,j]；

在最小化这三个目标中的三个之后，我们可以查看所有目标的求解状态值：

ampl: model transp4.mod; data assign.dat; solve;  
CPLEX 8.0.0：最优解；目标值 28 24 次对偶单纯形迭代（第 I 阶段 0 次）  
目标 = 总成本

mpl: objective Pref_of('Coullard');  
appl: solve;  
CPLEX 8.0.0：最优解；目标值 1 3 次单纯形迭代（第 I 阶段 0 次）  
appl: objective Pref_of('Hazen');  
appl: solve;  
CPLEX 8.0.0：最优解；目标值 1 5 次单纯形迭代（第 I 阶段 0 次）  
appl: display Total_Cost.result, Pref_of.result;  
Total_Cost.result = solved  
Pref_of.result [*] :=  
Coullard solved  
Daskin '?'  
Hazen solved  
Hopp '?'  
Iravani '?'  
Linetsky '?'  
Mehrotra '?'  
Nelson '?'  
Smilowitz '?'  
Tamhane '?'  
White '?';

对于尚未使用的那些目标，.result 后缀保持不变（在这种情况下为其初始值 '?'）。

这些相同的后缀也可以应用于我们将在本章后面描述其用途的 "problem" 名称。当附加到一个 problem 名称上时，它们指的是该 problem 当前时执行的最近一次优化。

# 变量的求解器状态

除了提供如上所述的优化过程整体状态的返回外，AMPL 还允许求解器为每个变量返回单独的状态。此功能主要用于在线性规划通过单纯形法 (simplex) 或由内点（障碍）方法后接 "crossover" 例程求解后，报告变量的基状态。基状态对于某些非线性求解器（尤其是 MINOS）所返回的解也相关，这些求解器采用了基本解概念的扩展。

除了 AMPL 模型中由 var 语句声明的变量外，求解器还定义与约束关联的 "松弛" 或 "人工" 变量。这些变量的求解器状态也以类似方式定义，如本节后面所述。变量和约束都有一个 "AMPL 状态"，用于区分当前问题中的那些变量和那些已通过预求解或诸如 drop 等命令从问题中移除的变量。AMPL 状态的解释及其与求解器状态的关系在本节末尾讨论。

最优基本解中求解器状态值的主要用途是为下一次优化运行提供良好的起点。当 send_statuses 选项保持其默认值 1 时，它会指示 AMPL 在每次求解时将状态信息与发送给求解器的变量信息一起包含进去。你可以在几乎任何在对问题进行小改动后重新求解的敏感性分析中看到此功能的效果。

例如，考虑当图 6-3 中的多周期生产 (multi-period production) 示例在劳动力可用量 (availability of labor) 增加百分之五后被重复求解时会发生什么。当 send_statuses 选项被设为 0 时，每次运行求解器 (solver) 都会报告大约 18 次对偶单纯形迭代 (dual simplex iterations)：

```ampl: model steelT3.mod;
ampl: data steelT3.dat;
ampl: option send_statuses 0;
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 514521.7143
18 dual simplex iterations (0 in phase I)
ampl: let {t in 1..T} avail[t] := 1.05 * avail[t];
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 537104
19 dual simplex iterations (0 in phase I)
ampl: let {t in 1..T} avail[t] := 1.05 * avail[t];
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 560800.4
19 dual simplex iterations (0 in phase I)
ampl: let {t in 1..T} avail[t] := 1.05 * avail[t];
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 585116.22
17 dual simplex iterations (0 in phase I)
```

然而，如果 send_statuses 保持默认值 1，则只有第一次求解需要 18 次迭代。随后的运行最多只需几次迭代：

```ampl: model steelT3.mod;
ampl: data steelT3.dat;
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 514521.7143
18 dual simplex iterations (0 in phase I)
ampl: let {t in 1..T} avail[t] := 1.05 * avail[t];
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 537104
2 dual simplex iterations (0 in phase I)
ampl: let {t in 1..T} avail[t] := 1.05 * avail[t];
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 560800.4
0 simplex iterations (0 in phase I)
ampl: let {t in 1..T} avail[t] := 1.05 * avail[t];
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 585116.22
1 dual simplex iterations (0 in phase I)
```

第一次之后的每次求解都会自动使用前一次求解中 变量 (variables) 的 基状态 (basis statuses) 来构建一个起点，该起点距离 最优解 (optimal solution) 仅需几次 迭代 (iterations) 即可到达。在第三次求解的情况下，前一个基仍然保持最优；因此，求解器立即确认最优性并报告进行了 0 次迭代。

以下讨论解释了如何在 AMPL 环境中查看、解释和更改变量的状态值。如上所示，您无需了解这些内容即可使用最优基作为起点，但在某些高级情况下，这些功能可能会很有用。

AMPL 通过在变量名后附加 `.sstatus` 来引用变量的 求解器状态 (solver status)。因此，您可以使用 display 打印变量的状态。在会话开始时（或在 reset 之后），当尚未解决任何问题时，所有变量的状态均为 none：

```matlab
ampl: model diet.mod;
ampl: data diet2a.dat;
ampl: display Buy.sstatus;
Buy.sstatus [*] :=
BEEF none    CHK none    FISH none    HAM none
MCH none    MTL none    SPG none    TUR none;
```

在调用 单纯形法 (simplex) 求解器后，同样的 display 命令将列出在最优基本解中变量的状态：

```matlab
ampl: solve;
MINOS 5.5: 找到最优解。
13 次迭代，目标函数值为 118.0594032
ampl: display Buy.sstatus;
Buy.sstatus [*] :=
BEEF bas
CHK low
FISH low
HAM upp
MCH upp
MTL upp
SPG bas
TUR low;
```

其中两个变量 Buy['BEEF'] 和 Buy['SPG'] 的状态为 bas，表示它们在最优基中。有三个变量的状态为 low，另外三个为 upp，分别表示它们是非基变量且处于 下界 (lower bound) 或 上界 (upper bound)。求解器状态值的对照表存储在选项 sstatus_table 中：

```ampl
option sstatus_table;
option sstatus_table '\
0 none 未分配状态\
1 bas 基变量\
2 sup 超基变量\
3 low 非基变量，通常等于下界\
4 upp 非基变量，通常等于上界\
5 equ 非基变量，上下界相等\
6 btw 非基变量，处于上下界之间\
';
```

前两列给出了表示状态值的数字和短字符串。（数字主要用于 AMPL 与求解器之间的通信，尽管你可以通过使用后缀 `.sstatus_num` 代替 `.sstatus` 来访问它们。）第三列是注释。对于许多教科书中单纯形法定义的非基变量，只有 `low` 状态适用；其他非基状态是为大规模实现中更通用的有界变量单纯形法所必需的。像 MINOS 这样的求解器使用 `sup` 状态来处理非线性问题。这是 AMPL 的标准 `sstatus_table`；求解器可能会替换为自己的对照表，在这种情况下，其文档将说明表中各项的含义。

你可以使用 `let` 命令更改变量的状态。当你希望在问题发生小的、明确定义的改变后重新求解时，这个功能有时会很有用。例如在本章后面的章节中，我们使用了一个模式切割模型（图 14-2a），其中包含如下声明：

```ampl
param nPAT integer >= 0;     # 模式数量
set PATTRNS = 1..nPAT;       # 模式集合
var Cut {PATTRNS} integer >= 0;  # 使用每种模式切割的卷数
```

在相关的脚本中（图 14-3），每次主循环执行时 `nPAT` 增加一，导致一个新的变量 `Cut[nPAT]` 被创建。它像所有新变量一样初始求解器状态为 `"none"`，但由于模式生成过程的构造方式，可以保证在扩展后的切割问题重新求解时立即进入基变量。因此我们将其状态设为 `"bas"`：

```ampl
let Cut[nPAT].sstatus := "bas";
```

事实证明，这种改变往往能够减少每次重新优化切割问题时的迭代次数，至少对于某些单纯形法求解器是如此。然而，以这种方式设置少量状态并不能保证减少迭代次数。其成功与否取决于具体的问题和求解器，以及它们与许多复杂因素的相互作用：

- 在问题和状态被修改后，传递给求解器 (solver) 的状态在下一次求解时可能无法正确定义一个基本解 (basic solution)。
- 在问题被修改后，除非将选项 `preserve` 设置为零，否则 AMPL 的预处理阶段 (presolve phase) 可能会向求解器发送变量和约束的不同子集。因此，传递给求解器的状态可能不是下一次求解有用起点，也可能无法正确定义一个基本解。

某些求解器（特别是 MINOS）在构建下一次求解的起点时，会使用变量的当前值以及变量的状态（除非将选项 `reset_initial_guesses` 设置为 1）。

每个求解器都有自己的一套方法，在必要时调整从 AMPL 接收到的状态，以生成一个它能够使用的初始基本解。因此，通常需要通过一些实验来确定修改状态的特定策略是否有用。

对于具有多个 var 声明的模型，AMPL 提供的变量通用同义词（第 12.6 节）为获取状态的整体摘要提供了便利方式。例如，在 display 语句中使用类似 `_var`、`_varname` 和 `_var.sstatus` 的表达式，可以轻松指定 steelT3.mod 中所有基本变量及其最优值的表格：

ampl: display {j in 1.._nvars: _var[j].sstatus = "bas"} (_varname[j], _var[j]);  
: _varname[j] _var[j] :=  
1 "Make['bands',1]" 5990  
2 "Make['bands',2]" 6000  
3 "Make['bands',3]" 1400  
4 "Make['bands',4]" 2000  
5 "Make['coils',1]" 1407  
6 "Make['coils',2]" 1400  
7 "Make['coils',3]" 3500  
8 "Make['coils',4]" 4200  
15 "Inv['coils',1]" 1100  
21 "Sell['bands',3]" 1400  
22 "Sell['bands',4]" 2000  
23 "Sell['coils',1]" 307  
;

通过命令 display _varname, _var; 可以生成所有变量的类似列表。

# 约束的求解器状态

单纯形法 (simplex method) 的实现通常会为从 AMPL 接收到的每个约束添加一个变量。每个添加的变量在其相关约束中的系数为 1 或 $-1$，而在所有其他约束中的系数为 0。如果相关约束是一个不等式，则该添加变量用作“松弛变量 (slack)”或“剩余变量 (surplus)”；其边界被选择为能够将不等式转化为等价的方程。如果相关约束本身就是等式，则添加的变量是一个“人工变量 (artificial)”，其上下界均为零。

高效的大型单纯形求解器通过将这些“逻辑变量 (logical variables)”添加到从 AMPL 获得的“结构变量 (structural variables)”中，获得了两个优势：线性规划问题

被转换为一种更简单的形式，其中唯一的不等式是变量的边界，而求解器的初始化 (或称为 "crash") 例程可以被设计为快速找到一个初始基。给定任何初始基，单纯形法的第一阶段会找到一个可行解的基 (如有必要)，第二阶段则找到一个最优解的基；在某些求解器的消息中，这两个阶段是有所区分的：

```python
ampl: model steelP.mod;
ampl: data steelP.dat;
ampl: solve;
CPLEX 8.0.0: optimal solution; objective 139217527
dual simplex iterations (0 in phase I)
```

因此，求解器通常以与结构变量几乎相同的方式处理所有逻辑变量，仅需非常小的调整来处理上下限均为零的情况。一个基本解由所有变量 (结构变量和逻辑变量) 的基状态集合所定义。

为了适应逻辑变量的状态，AMPL 允许求解器返回与约束以及变量相对应的状态值。约束的求解器状态写作约束名称后缀加上 .sstatus，被解释为与该约束相关联的逻辑变量的状态。例如，在我们的饮食模型中，所有约束都是不等式：

```python
subject to Diet {i in NUTR}:
    n_min[i] <= sum {j in FOOD} amt[i,j] * Buy[j] <= n_max[i];
```

逻辑变量是松弛变量，其状态种类与结构变量相同：

```python
ampl: model diet.mod;
ampl: data diet2a.dat;
ampl: option show_stats 1;
ampl: solve;
8 variables, all linear
6 constraints, all linear; 47 nonzeros
1 linear objective; 8 nonzeros.
MINDS 5.5: optimal solution found.
13 iterations, objective 118.0594032
```

```python
ampl: display Buy.sstatus;
Buy.sstatus [+] :=
BEEF  bas
CHK   low
FISH  low
HAM   upp
MCH   upp
MTL   upp
SPG   bas
TUR   low
;

ampl: display Diet.sstatus;
Diet.sstatus [*] :=
A   bas
B1  bas
B2  low
C   bas
CAL bas
NA  upp
```

总共有 六个 基本 变量 (basic variable)，数量 与 六个 约束 (constraint) (集合 NUTR 的 每个 成员 对应 一个) 相等，这 在 基本 解 (basic solution) 中 总是 成立 的。在 我们 的 运输 模型 (transportation model) 中，约束 是 等式：

```python
subject to Supply {i in ORIG}:
    sum {j in DEST} Trans[i,j] = supply[i];

subject to Demand {j in DEST}:
    sum {i in ORIG} Trans[i,j] = demand[j];
```

逻辑 变量 (logical variable) 是 人工 变量 (artificial variable)，当 它们 是 非 基本 变量 (nonbasic variable) 时，状态 为 "equ"。以下是 使用 AMPL 的 通用 约束 同义词 (generic constraint synonym) (类似于 之前 展示 的 变量 同义词 (variable synonym)) 显示 所有 约束 状态 (constraint status) 的 方法：

ampl: model transp.mod;  
ampl: data transp.dat;  
ampl: solve;  
MINOS 5.5: optimal solution found.  
13 iterations, objective 196200  
ampl: display _conname, _con.slack, _con.sstatus;  

: _conname _con.slack _con.sstatus :=  
1 "Supply['GARY']" - 4.54747e- 13 equ  
2 "Supply['CLEV']" 0 equ  
3 "Supply['PITT']" - 4.54747e- 13 equ  
4 "Demand['FRA']" - 6.82121e- 13 bas  
5 "Demand['DET']" 0 equ  
6 "Demand['LAN']" 0 equ  
7 "Demand['WIN']" 0 equ  
8 "Demand['STL']" 0 equ  
9 "Demand['FRE']" 0 equ  
10 "Demand['LAF']" 0 equ  
;

有一个 人工 变量 (artificial variable) 出现 在 最优 基 (optimal basis) 中，即 约束 Demand['FRA'] 对应 的 变量，尽管 其 松弛 值 (slack value) 本质 上 为 零，就 像 任何 可行 解 (feasible solution) 中 所有 的 人工 变量 一样。(事实上，由于 模型 中 方程 存在 线性 依赖 关系 (linear dependence)，这个 问题 的 每个 基 (basis) 中 都 必须 包含 一些 人工 变量。)

# AMPL 状态

只有 那些 AMPL 实际 发送 给 求解器 (solver) 的 变量 (variable)、目标 函数 (objective) 和 约束 (constraint)，在 求解 后 才能 接收 到 求解器 的 状态 (solver status)。因此，为 了 区分 这些 与 在 求解 前 被 移除 的 组件 (component)，AMPL 还 维护 了 一个 单独 的 “AMPL 状态” (AMPL status)。你 可以 像 处理 求解器 状态 一样 处理 AMPL 状态，只需 使用 后缀 .astatus 替代 .sstatus，并 参考 选项 astatus_table 获取 被 识别 值 的 总结：

ampl: option astatus_table;  
option astatus_table '\  
0 in normal state (in problem)  
1 drop removed by drop command  
2 pre eliminated by presolve  
3 fix fixed by fix command  
4 sub defined variable, substituted out  
5 unused not used in current problem  
1  

下面 是 一个 常见 情况 的 示例，使用 了 我们 的 一个 饮食 模型 (diet model)：

ampl: model dietu.mod;  
ampl: data dietu.dat;  
ampl: drop Diet_Min['CAL'];  
ampl: fix Buy['SPG'] := 5;  
ampl: fix Buy['CHK'] := 3;  
ampl: solve;  
MINDS 5.5: optimal solution found.  
3 iterations, objective 54.76  
ampl: display Buy.astatus;  

Buy.astatus [*] :=  
BEEF in  
CHK fix  
FISH in  
HAM in  
MCH in  
MTL in  
SPG fix  
TUR in  
;  

ampl: display Diet_Min.astatus;  

Diet_Min.astatus [*] :=  
A in  
B1 pre  
B2 pre  
C in  
CAL drop  
;
```

一个 AMPL 状态为 `in` 表示该组件被包含在发送给 求解器 的问题中，例如变量 `Buy['BEEF']` 和约束 `Diet_Min['A']`。其他三种状态表示被排除在问题之外的组件：

- 变量 `Buy['CHK']` 和 `Buy['SPG']` 的 AMPL 状态为 `"fix"`，因为使用了 `fix` 命令来指定它们在解中的值。  
- 约束 `Diet_Min['CAL']` 的 AMPL 状态为 `"drop"`，因为它被 `drop` 命令移除了。  
- 约束 `Diet_Min['B1']` 和 `Diet_Min['B2']` 的 AMPL 状态为 `"pre"`，因为它们在 AMPL 的 presolve 阶段被简化操作移除了。

此处未显示 AMPL 状态 `"unused"`，该状态用于表示未出现在任何 目标函数 或约束中的变量；以及状态 `"sub"`，用于表示通过代入法 （如第 18.2 节所述） 被消除的变量和约束。本章后面将定义的 `objective` 命令及 `problem` 命令也会起到固定或丢弃未使用模型组件的作用。

对于一个变量或约束，通常你只关注其中一种状态：如果该变量或约束被包含在最近一次发送给 求解器 的问题中，则关注 求解器 状态；否则关注 AMPL 状态。因此，AMPL 提供了后缀 `.status` 来表示当前关注的状态：

```
ampl: display Buy.status, Buy.astatus, Buy.sstatus;
: Buy.status Buy.astatus Buy.sstatus :=
BEEF low in low
CHK fix fix none
FISH low in low
HAM low in low
MCH bas in bas
MTL low in low
SPG fix fix none
TUR low in low

ampl: display Diet_Min.status, Diet_Min.astatus,
ampl? Diet_Min.sstatus;
: Diet_Min.status Diet_Min.astatus Diet_Min.sstatus :=
A bas in bas
B1 pre pre none
B2 pre pre none
C low in low
CAL drop drop none
```

通常，如果 `name.astatus` 为 `"in"`，则 `name.status` 等于 `name.sstatus`，否则 `name.status` 等于 `name.astatus`。

# 14.3 通过后缀与 求解器 交换信息

我们已经看到，为了表示与模型组件相关的值，AMPL 使用附加在组件名称后的各种限定符或 后缀。后缀由一个句点或“点”(.) 加上一个（通常较短的）标识符组成。例如，与变量 `Buy[j]` 相关的 约简成本 写作 `Buy[j].rc`，而所有此类变量的约简成本可以通过命令 `display Buy.rc` 查看。有许多内置的此类后缀，详见 A.11 节中的表格。

然而，AMPL 无法预知 求解器 可能与模型组件关联的所有值。这些值作为输入被识别或作为输出被计算，取决于每个 求解器 及其算法的设计。为了提供一种开放式的表示方式，可以在 AMPL 会话期间定义新的 后缀，这些 后缀 可以由用户定义用于向 求解器 发送值，也可以由 求解器 定义用于返回值。

本节介绍了用户定义和求解器定义的后缀，并以 CPLEX 求解器的功能为例进行说明。我们展示了用户定义的后缀如何向整数规划求解器传递变量选择和分支方向的偏好。敏感性分析提供了一个具有数值的求解器定义后缀的例子，而不可行性诊断则展示了符号型（字符串值）后缀的工作方式。在 AMPL 脚本中报告无界方向的例子中，展示了求解器定义的后缀，必须在使用前对其进行声明。

# 用户定义后缀：整数规划指令

大多数 求解器 (solver) 都能识别 各种 算法选择 或 设置，每种 设置 都由 一个 单一 的 值 控制，该 值 适用于 整个 被求解 的 问题。因此，你可以 通过 设置 一串 指令 来 修改 选定 的 设置，如下 例 所示，将 CPLEX 求解器 应用于 一个 整数 规划 问题：

```matlab
ampl: model multmip3.mod;
ampl: data multmip3.dat;
ampl: option solver cplex;
ampl: option cplex_options 'nodesel 3 varsel 1 backtrack 0.1';
ampl: solve;
CPLEX 8.0.0: nodesel 3
varsel 1
backtrack 0.1
CPLEX 8.0.0: optimal integer solution; objective 2356251052
MIP simplex iterations 75
branch-and-bound nodes
```

然而，有 一些 求解器 设置 更为 复杂，因为 它们 需要 为 模型 中 的 每个 组件 单独 设置 值。这些 设置 数量 太多，无法 用 一串 指令 来 表示。因此，求解器 接口 可以 被 设置 为 能够 识别 用户 为 求解器 目的 而 特别 定义 的 新 后缀 (suffix)。

例如，对于 整数 规划 中 的 每个 变量，CPLEX 都 能 识别 一个 独立 的 分支 优先级 和 一个 独立 的 优选 分支 方向，分别 用 区间 $[0, 9999]$ 和 $[-1, 1]$ 中 的 整数 表示。AMPL 的 CPLEX 驱动 程序 将 后缀 `.priority` 和 `.direction` 识别 为 这些 设置。要 使用 这些 后缀，我们 首先 通过 一个 后缀 命令 来 为 当前 的 AMPL 会话 定义 每个 后缀：

```matlab
ampl: suffix priority IN, integer, >= 0, <= 9999;
ampl: suffix direction IN, integer, >= -1, <= 1;
```

这些 语句 的 效果 是 定义 形如 `name.priority` 和 `name.direction` 的 表达式，其中 `name` 表示 当前 模型 中 的 任意 变量、目标 或 约束。参数 `IN` 指定 这些 后缀 对应 的 值 将 被 求解器 读取，随后 的 短语 则 对 可接受 的 值 进行 限制（类似于 参数 声明 中 的 用法）。

这些 新定义 的 后缀 可以 通过 `let` 命令（第 11.3 节）或 后续 的 声明（如 A.8、A.9、A.10 和 A.18.8 节 所述）来 赋值。在 当前 示例 中，我们 希望 使用 这些 后缀 来 为 二元 变量 `Use[i, j]` 分配 对应 的 CPLEX 优先级 和 方向 值。通常，这些 值 是 基于 对 问题 的 了解 和 与 类似 问题 的 经验 来 选择 的。以下是 一种 可能 的 设置：

```matlab
ampl: let {i in ORIG, j in DEST} Use[i,j].priority := sum {p in PROD} demand[j,p];
ampl: let Use["GARY","FRE"].direction := -1;
```

未 被 赋予 `.priority` 或 `.direction` 值 的 变量 将 被 赋予 默认 值 零（在 本例 中，所有 约束 和 目标 也是如此），你可以 通过 如下 命令 查看：

```matlab
ampl: display Use.direction;
Use.direction [*,*] (tr) :
           CLEV  GARY  PITT :=
    DET      0     0     0
    FRA      0     0     0
    FRE      0    -1     0
    LAF      0     0     0
    LAN      0     0     0
    STL      0     0     0
    WIN      0     0     0
;
```

在 如上 所示 赋予 后缀 值 后，CPLEX 在 搜索 解 的 过程 中 所需 的 单纯形法 (simplex) 迭代 次数 和 分支定界 (branch- and- bound) 节点 数 都 减少 了：

```matlab
ampl: option reset_initial_guesses 1;
ampl: solve;
CPLEX 8.0.0: nodesel 3
varsel 1
backtrack 0.1
CPLEX 8.0.0: optimal integer solution; objective 235625799
69 MIP simplex iterations
1 branch- and- bound nodes
```

(我们将选项 reset_initial_guesses 设置为 1，以便第一次 CPLEX 运行的最优解不会被传递回第二次运行。)

有关 CPLEX 识别的后缀以及如何确定相应设置的更多信息，请参阅 CPLEX 驱动程序文档。其他求解器接口可能为不同目的识别不同的后缀；您需要分别检查每个想要使用的求解器。

# 求解器定义的后缀：敏感性分析

当关键字 sensitivity 包含在 CPLEX 的指令列表中时，将计算经典敏感性范围，并在三个新后缀 `.up`、`.down` 和 `.current` 中返回：

```matlab
ampl: model steelT.mod; data steelT.dat;
ampl: option solver cplex;
ampl: option cplex_options 'sensitivity';
ampl: solve;
CPLEX 8.0.0: sensitivity
CPLEX 8.0.0: optimal solution; objective 515033
16 dual simplex iterations (0 in phase I)
suffix up OUT;
suffix down OUT;
suffix current OUT;
```

求解命令输出末尾的三行显示了 AMPL 根据求解器结果自动执行的后缀命令。这些语句是自动执行的；您无需手动输入。每个命令中的参数 OUT 表示这些是求解器将写出值的后缀（与前面的例子形成对比，其中参数 IN 表示求解器应读入的后缀值）。

敏感性后缀的解释如下。对于变量，后缀 `.current` 表示当前问题中的目标函数 (objective) 系数，而 `.down` 和 `.up` 给出目标系数的最小和最大值，使得当前 LP 基保持最优：

<table><tr><td colspan="4">ampl: display Sell.down, Sell.current, Sell.up;</td><td></td></tr><tr><td></td><td>Sell.down</td><td>Sell.current</td><td>Sell.up</td><td>:=</td></tr><tr><td>bands 1</td><td>23.3</td><td>25</td><td>1e+20</td><td></td></tr><tr><td>bands 2</td><td>25.4</td><td>26</td><td>1e+20</td><td></td></tr><tr><td>bands 3</td><td>24.9</td><td>27</td><td>27.5</td><td></td></tr><tr><td>bands 4</td><td>10</td><td>27</td><td>29.1</td><td></td></tr><tr><td>coils 1</td><td>29.2857</td><td>30</td><td>30.8571</td><td></td></tr><tr><td>coils 2</td><td>33</td><td>35</td><td>1e+20</td><td></td></tr><tr><td>coils 3</td><td>35.2857</td><td>37</td><td>1e+20</td><td></td></tr><tr><td>coils 4</td><td>35.2857</td><td>39</td><td>1e+20</td><td></td></tr><tr><td>;</td><td></td><td></td><td></td><td></td></tr></table>

对于约束 (constraint)，解释类似，但适用于约束的常数项（所谓的右侧值）：

<table><tr><td colspan="4">ampl: display Time.down, Time.current, Time.up;</td><td></td></tr><tr><td></td><td>Time.down</td><td>Time.current</td><td>Time.up</td><td>:=</td></tr><tr><td>1</td><td>37.8071</td><td>40</td><td>66.3786</td><td></td></tr><tr><td>2</td><td>37.8071</td><td>40</td><td>47.8571</td><td></td></tr><tr><td>3</td><td>25</td><td>32</td><td>45</td><td></td></tr><tr><td>4</td><td>30</td><td>40</td><td>62.5</td><td></td></tr><tr><td>;</td><td></td><td></td><td></td><td></td></tr></table>

你可以使用通用同义词 (第 12.6 节) 来显示所有变量或约束的范围表，类似于独立版本的 CPLEX 生成的表格。（在 .down 列中值为 $-1e+20$ 以及在 .up 列中值为 $1e+20$ 对应于 CPLEX 在其表格中称为 -无穷大和 +无穷大。）

# 求解器定义的后缀：不可行性诊断

对于没有可行解的线性规划，你可以要求 CPLEX 找到一个不可约的不可行子集 (Irreducible Infeasible Subset，或称为 IIS)：一组约束和变量边界，它们是不可行的，但当移除其中任意一个约束或边界时就变为可行。如果存在一个较小的 IIS 并且可以找到，它能够为不可行性的来源提供有价值的线索。你可以通过将 iisfind 指令从默认值 0 更改为 1（用于相对较快的版本）或 2（用于较慢的版本，但倾向于找到更小的 IIS）来开启 IIS 查找器。

以下示例展示了如何将 IIS 查找应用于第 2 章中的不可行饮食问题。在 solve 检测到没有可行解之后，使用指令 'iisfind 1' 重新求解：

ampl: model diet.mod; data diet2.dat; option solver cplex;
ampl: solve;
CPLEX 8.0.0: 不可行问题。
4 次对偶单纯形迭代 (第 I 阶段 0 次)
constraint.dunbdd 返回
后缀 dunbdd OUT;
ampl: option cplex_options 'iisfind 1';
ampl: solve;
CPLEX 8.0.0: iisfind 1
CPLEX 8.0.0: 不可行问题。
0 次单纯形迭代 (第 I 阶段 0 次)
返回包含 7 个变量和 2 个约束的 iis。
constraint.dunbdd 返回
后缀 iis symbolic OUT;
option iis_table '\
0 non 不在 iis 中\
1 low 在下界\
2 fix 固定\
3 upp 在上界\
';

同样，AMPL 会显示任何已自动执行的后缀语句。我们关注的是名为 `.iis` 的新后缀，它是符号型或字符串值的。相关的选项 `iis_table` 也由求解器驱动程序设置，并由 `solve` 自动显示，它展示了可能与 `.iis` 关联的字符串并简要描述了它们的含义。

你可以使用 `display` 查看返回的 `.iis` 值：

```
ampl: display _varname, _var.iis, _conname, _con.iis;
_varname _var.iis _conname _con.iis :=
"Buy['BEEF']" upp "Diet['A']" non
"Buy['CHK']" low "Diet['B1']" non
"Buy['FISH']" low "Diet['B2']" low
"Buy['HAM']" upp "Diet['C']" non
"Buy['MCH']" non "Diet['NA']" upp
"Buy['MTL']" upp "Diet['CAL']" non
"Buy['SPG']" low "Buy['TUR']" low
```

这些信息表明，不可行约束集 (IIS) 包含变量的四个下界和三个上界，以及提供饮食中维生素 B2 下界和钠上界的约束。这些限制共同作用时无可行解，但去掉其中任意一个限制后，其余限制将允许找到一个解。

如果对去掉边界不感兴趣，则可能只想列出 IIS 中的约束。一条打印语句可以生成一个简洁的列表：

```
ampl: print {i in 1.._ncons: _con[i].iis != "non"} _conname[i];
Diet['B2']
Diet['NA']
```

在这种情况下，你可以得出结论：为了避免违反购买数量的边界，可能需要在饮食中接受较少的维生素 B2 或较多的钠，或者两者兼而有之。然而，要进一步确定具体需要减少或增加多少，以及为了获得可行性可能需要接受哪些其他变化，则需要进一步的实验。（一个线性规划可能有多个不可约的不可行子集，但 CPLEX 的 IIS 查找算法一次只能检测到一个 IIS。）

# 求解器定义的后缀：无界性的方向

对于一个无界的线性规划——即实际上具有最小值 $-\infty$ 或最大值 $+\infty$ 的线性规划——求解器可以返回形式为 $X + \alpha d$ 的可行解射线，其中 $\alpha \geq 0$。从 CPLEX 返回时，可行解 $X$ 由变量的值给出，而无界性方向 $d$ 则通过求解器定义的后缀 `.unbdd` 与每个变量关联的附加值给出。

无界性方向的一个应用可以在模型 `trnlocld.mod` 和脚本 `trnlocld.run` 中找到，该模型和脚本将 Benders 分解应用于仓库选址和运输问题的组合；该模型、数据和脚本可从 AMPL 网站获得。我们不会在这里尝试描述整个分解方案，而是专注于通过将零一变量 `Build[i]`（表示要建造的仓库）固定为试验值 `build[i]` 而得到的子问题。在其对偶形式中，该子问题为：

```
var Supply_Price {ORIG} <= 0;
var Demand_Price {DEST};

maximize Dual_Ship_Cost:
    sum {i in ORIG} Supply_Price[i] * supply[i] * build[i] +
    sum {j in DEST} Demand_Price[j] * demand[j];

subject to Dual_Ship {i in ORIG, j in DEST}:
    Supply_Price[i] + Demand_Price[j] <= cost[i,j];
```

当所有 `build[i]` 值都设置为零时，不建造任何仓库，原始子问题是不可行的。因此，始终具有可行解的子问题的对偶形式必须是无界的。

正如本章其余部分将解释的那样，我们通过将子问题的组件收集到一个 AMPL "problem" 中，然后指示 AMPL 仅求解该问题来解决子问题。当从 AMPL 命令行应用此方法到对偶子问题时，CPLEX 以预期的方式返回无界性方向：

```
ampl: model trnloc1d.mod;  
ampl: data trnloc1.dat;  
ampl: problem Sub: Supply_Price, Demand_Price, Dual_Ship_Cost, Dual_Ship;  
ampl: let {i in ORIG} build[i] := 0;  
ampl: option solver cplex, cplex_options 'presolve 0';  
ampl: solve;  
CPLEX 8.0.0: presolve 0  
CPLEX 8.0.0: unbounded problem.  
25 dual simplex iterations (25 in phase I)  
variable.unbdd returned 6 extra simplex iterations for ray (1 in phase I)  
suffix unbdd OUT;
```

后缀信息表明，`.unbdd` 已被自动创建。你可以使用该后缀来显示无界方向，在本例中很简单：

```
ampl: display Supply_Price.unbdd;  
Supply_Price.unbdd [*] :=  
1 - 1  
4 - 1  
7 - 1  
10 - 1  
13 - 1  
16 - 1  
19 - 1  
22 - 1  
25 - 1  
2 - 1  
5 - 1  
8 - 1  
11 - 1  
14 - 1  
17 - 1  
20 - 1  
23 - 1  
3 - 1  
6 - 1  
9 - 1  
12 - 1  
15 - 1  
18 - 1  
21 - 1  
24 - 1  
;  

ampl: display Demand_Price.unbdd;  
Demand_Price.unbdd [*] :=  
A3 1  
A6 1  
A8 1  
A9 1  
B2 1  
B4 1  
;
```

我们用于 Benders 分解的脚本（trnloc1d.run）会反复求解子问题，并根据主问题生成不同的 `build[i]` 值。每次求解后都会测试结果是否无界，并据此构造主问题的一个扩展。主循环的核心如下：

```
repeat {  
solve Sub;  
if Dual_Ship_Cost $<=$ Max_Ship_Cost $+$ 0.00001 then break;  
if Sub.result $=$ "unbounded" then {  
let nCUT := nCUT + 1;  
let cut_type[nCUT] := "ray";  
let {i in ORIG} supply_price[i,nCUT] := Supply_Price[i].unbdd;  
let {j in DEST} demand_price[j,nCUT] := Demand_Price[j].unbdd;  
} else {  
let nCUT := nCUT + 1;  
let cut_type[nCUT] := "point";  
let {i in ORIG} supply_price[i,nCUT] := Supply_Price[i];  
let {j in DEST} demand_price[j,nCUT] := Demand_Price[j];  
}  
solve Master;  
let {i in ORIG} build[i] := Build[i];  
}
```

然而，在此上下文中尝试使用 `.unbdd` 会失败：

```
ampl: commands trnlocld.run;  
trnlocld.run, line 39 (offset 931): Bad suffix .unbdd for Supply_Price  
context: let {i in ORIG} supply_price[i,nCUT] := >>> Supply_Price[i].unbdd; <<<
```

问题在于 AMPL 在开始执行任何命令之前会扫描整个 repeat 循环中的所有命令。因此，它在任何不可行的子问题有机会定义该后缀之前就遇到了对 `.unbdd` 的使用。为使脚本按预期运行，需要在 repeat 循环之前添加语句 `suffix unbdd OUT;`，以便在扫描循环时 `.unbdd` 已经被定义。

# 定义和使用后缀

一个新的 AMPL 后缀 (suffix) 通过一个由关键字 suffix、后缀名以及一个或多个可选限定符 (qualifier) 组成的语句来定义，这些限定符用于指示可以与该后缀关联的值以及其使用方式。例如，我们已经看到定义 suffix priority IN, integer, $\geq 0$, $\leq 9999$，其中包含输入输出 (IN)、类型 (integer) 和边界 ($\geq 0$, $\leq 9999$) 限定符。

后缀语句使得 AMPL 能够识别形如 `component-name.suffix-name` 的后缀表达式，其中 `component-name` 指代任何当前已声明的 变量 (variable)、约束 (constraint) 或目标函数（或下一节中定义的问题）。后缀的定义将一直有效，直到下一次 reset 命令或当前 AMPL 会话结束。`suffix-name` 遵循与 AMPL 中其他名称相同的命名规则。但后缀拥有独立的命名空间，因此后缀可以与参数、变量或其他模型组件同名。后缀语句中的可选限定符可以以任意顺序出现；它们的形式和作用如下所述。

后缀语句中的可选类型限定符用于指示可以与后缀表达式相关联的值类型，默认情况下为所有数值：

```rsuffix type values allowed
none specified 任意数值
integer 整数数值
binary 0 或 1
symbolic 由 option suffix-name_table 指定的字符串列表
```

所有数值型后缀表达式的初始值为 0。它们允许的取值范围还可以通过如下形式的一个或两个边界限定符进一步限制：

$$ \text{arith-expr} \leq \text{arith-expr} $$

其中 `arith-expr` 是任何不包含变量的算术表达式。

对于每个符号型后缀，AMPL 会自动定义一个相关的数值型后缀 `suffix-name_num`。此时必须创建一个 AMPL 选项 `suffix-name_table`，用于定义 `.suffix-name` 与 `.suffix-name_num` 值之间的对应关系，如下例所示：

```rsuffix iis symbolic OUT;
option iis_table '\0 non not in the iis\1 low at lower bound\2 fix fixed\3 upp at upper bound\';
```

表中的每一行由一个整数值、一个字符串值和一个可选注释组成。每个字符串值都与其相邻的整数值相关联，并且也与小于下一行整数的更高整数值相关联。将字符串值赋给 `.suffix-name` 表达式等价于将对应的数值赋给 `.suffix-name_num` 表达式。后者的初始值为 0，并遵循上述的类型和边界限定符。（通常在 AMPL 命令和脚本中使用符号后缀的字符串值，而在与求解器通信时使用数值。）

可选的 in-out 限定符用于确定后缀值与求解器之间的交互方式：

in-out 后缀值的处理方式

IN 由 AMPL 在调用求解器前写入，然后由求解器读取  
OUT 由求解器写入，然后由 AMPL 在求解器完成后读取  
INOUT 既读又写，如上述 IN 和 OUT  
LOCAL 既不读也不写

如果未指定 in-out 关键字，则默认为 INOUT。

我们已经看到，可以通过 let 语句对后缀表达式进行赋值或重新赋值：

```let Use["GARY","FRE"].direction := -1;```

这里仅对一个变量赋值了 suffix 值，但通常索引集合中的所有变量都会被赋值 suffix：

```ampl
var Use {ORIG, DEST} binary;
let {i in ORIG, j in DEST} Use[i,j].priority := sum {p in PROD} demand[j,p];
```

在这种情况下，suffix 值的赋值可以与变量的声明合并：

```ampl
var Use {i in ORIG, j in DEST} binary,
    suffix priority sum {p in PROD} demand[j,p];
```

一般来说，`var` 声明中的一个或多个短语可以由关键字 `suffix` 组成，后跟一个先前定义的 suffix 名称以及用于计算相关 suffix 表达式的表达式。

# 14.4 模型之间的交替

第 13 章描述了如何设置 AMPL 命令的“脚本”，以运行执行重复操作的程序。在多个示例中，脚本通过在循环中包含 `solve` 语句来求解一系列相关的模型实例。结果是一个简单的灵敏度分析算法，使用 AMPL 的命令语言编程实现。

通过使用两个模型，可以构建更强大的算法过程。一个模型的最优解为另一个模型提供新数据，两个模型交替求解，直到最终满足某个终止条件。经典的列生成、割平面生成、分解和拉格朗日松弛方法都是基于这种方案，这些方法在本章末尾引用的文献中有详细描述。

要以这种方式使用两个模型，脚本必须有某种方式在它们之间切换。切换可以通过预先定义的 AMPL 特性完成，或者更清晰高效地通过定义分别命名的问题和环境来实现。

我们通过一个用于“卷材修整”或“下料问题”的基本形式的脚本来说明这些可能性，使用一种著名的、基础的列生成过程。为了简洁起见，我们在此仅简要描述该过程，而本章末尾的参考文献提供了详细描述的来源。AMPL 网站上有其他几个生成、分解和松弛方案的示例，我们稍后也会使用其中的一些片段，但不会展示完整模型。

在卷材修整问题中，我们希望将某种商品（如纸卷）的长原始宽度切割成较小宽度的组合，以满足给定订单，并尽可能减少浪费。这个问题可以看作是决定在每个原始宽度的卷材上应在哪里进行切割，以生产出一个或多个已订购的小宽度。然而，用决策变量来表达这样的问题很不方便，并且会导致一个整数规划问题，除非实例非常小，否则很难求解。

为了推导出一个更易于处理的模型，所谓的 Gilmore-Gomory 方法定义了一个切割模式 (cutting pattern) 为原材料卷的一种可行切割方式。因此，一个模式由各种所需宽度的卷材数量构成，且这些卷材的总宽度不得超过原材料的宽度。如果 (如在练习 2-6 中) 原材料宽度为 $110"$，而所需宽度有 $20"$、$45"$、$50"$、$55"$ 和 $75"$，那么两个 $45"$ 的卷材和一个 $20"$ 的卷材便构成一个可接受的模式，同样地，一个 $50"$ 和一个 $55"$ 的卷材 (剩余 $5"$ 的废料) 也构成一个可接受的模式。基于这种观点，图 14-2 中的两个简单线性 program (linear program) 可以协同工作，从而找到一个高效的切割方案。

切割优化模型 (图 14-2a) 用于在给定一系列已知可使用的切割模式的前提下，找到所需切割的原材料卷的最小数量 (min)。这实际上与饮食模型非常相似，其中 variables (variables) 表示被切割的模式而不是被购买的食物项，而 constraints (constraints) 则对切割宽度施加下限，而不是对提供的营养成分施加下限。

模式生成模型 (图 14-2b) 则试图识别出一个新的模式，该模式可用于切割优化中，以减少所需原材料卷的数量，或者确定不存在这样的新模式。该模型的 variable (variable) 是新模式中每种所需宽度的数量；唯一的 constraint (constraint) 确保该模式的总宽度不超过原材料宽度。我们在此不打算解释其目标函数，只是指出 variables (variable) 的系数由切割优化模型的线性松弛所对应的“对偶值 (dual value)”或“对偶价格 (dual price)”给出。

我们可以通过反复交替求解这两个问题来寻找一个良好的切割方案。首先，切割优化问题的连续 variables 松弛生成一些对偶价格，然后模式生成问题利用这些价格生成一个新模式，接着在模式集合扩展一个模式后重复该过程。当我们重复该过程直到模式生成问题表明不存在新模式可以带来改进时，我们就停止重复。此时，我们便得到了在 (可能) 切割分数个原材料卷的情况下的最优解。我们还可以在恢复整数 constraints 的条件下，最后一次运行切割优化模型，以得到最佳的整数解——

参数 roll_width $> 0$ # 原始卷的宽度  
集合 WIDTHS # 需要切割的宽度集合  
参数 orders {WIDTHS} $> 0$ # 每种宽度的需求量  
参数 nPAT 整数 $\geq 0$ # 模式数量  
集合 PATTERNS $= \{1, 2, \ldots, \mathrm{nPAT}\}$ # 模式集合  
参数 nbr {WIDTHS, PATTERNS} 整数 $\geq 0$  
检查 {j in PATTERNS}: sum {i in WIDTHS} i * nbr[i,j] $\leq$ roll_width # 模式的定义：nbr[i,j] 表示在模式 j 中宽度为 i 的卷的数量  
变量 Cut {PATTERNS} 整数 $\geq 0$ # 使用每种模式切割的卷数  
最小化 Number: # 最小化切割的原始卷总数  
sum {j in PATTERNS} Cut[j]  
约束 Fill {i in WIDTHS}:  
sum {j in PATTERNS} nbr[i,j] * Cut[j] $\geq$ orders[i] # 对于每种宽度，切割的总卷数满足总需求量  

图 14-2a：基于模式的切割优化问题模型 (cut.mod)

参数 price {WIDTHS} 默认值 0.0 # 切割优化的对偶价格  
变量 Use {WIDTHS} 整数 $\geq 0$ # 每种宽度在模式中的数量  
最小化 Reduced Cost: 1 - sum {i in WIDTHS} price[i] * Use[i]  
约束 Width_Limit: sum {i in WIDTHS} i * Use[i] $\leq$ roll_width  

图 14-2b：用于模式生成问题的背包模型 (cut.mod, 续)

使用生成的模式进行优化，或者我们可以简单地将分数卷数向上取整到下一个最大整数，如果结果可以接受的话。

这就是 Gilmore-Gomory 过程。就我们的两个 AMPL 模型而言，其步骤可以描述如下：

选择足以满足需求的初始模式  
重复  
求解 (分数) 切割优化问题  
令 price[i] 等于 Fill[i].dual  
对每个模式 i 求解模式生成问题  
如果最优值 $< 0$，则添加一个新模式，该模式切割 Use[i] 个宽度为 i 的卷  
否则找到最终整数解并停止  

一种简单的初始化方法是为每种宽度生成一个模式，该模式包含尽可能多的该宽度副本，以适应原始卷的宽度。这些模式显然可以覆盖任何需求，尽管不一定以经济的方式。

图 14-3 显示了作为 AMPL 脚本实现的 Gilmore-Gomory 过程。文件 cut.mod 包含图 14-2 中的切割优化和模式生成模型。由于这些模型没有共同的变量或约束，因此可以使用简单的 solve 语句和交替的目标函数编写脚本：

repeat { objective Number; solve; .. objective Reduced Cost; solve; }

然而，在这种方法下，每次 solve 都会将两个模型生成的所有变量和约束发送给求解器。这种安排效率低下且容易出错，特别是在处理更大更复杂的迭代过程时。

我们可以通过使用 fix 和 drop 命令来抑制其他变量和约束，从而确保只将当前相关的变量和约束发送给求解器。然后，我们的循环结构将如下所示：

repeat {unfix Cut; restore Fill; objective Number; fix Use; drop Width_Limit; solve; ... unfix Use; restore Width_Limit; objective Reduced Cost; fix Cut; drop Fill; solve; ...}

在每次 solve 之前，先前固定的 variable 和被丢弃的 constraint 也必须通过 unfix 和 restore 命令恢复。这种方法虽然高效，但极易出错，并且使脚本难以阅读。

因此，作为替代方案，AMPL 允许通过 problem 语句来区分模型，如图 14-3 所示：

problem Cutting_Opt: Cut, Number, Fill; option relax_integrality 1; problem Pattern_Gen: Use, Reduced_Cost, Width_Limit; option relax_integrality 0;

第一条语句定义了一个名为 Cutting_Opt 的 problem，它由 Cut 变量、Fill 约束以及目标函数 Number 组成。该语句同时将 Cutting_Opt 设为当前 problem；后续对 var、minimize、maximize、subject to 和 option 语句的使用将仅作用于该 problem。例如，通过将 option relax_integrality 设置为 1，我们确保当 Cutting_Opt 为当前 problem 时，Cut 变量的整数条件会被放松。类似地，我们定义另一个 problem Pattern_Gen，它由 Use 变量、Width_Limit 约束和目标函数 Reduced_Cost 组成；该 problem 成为新的当前 problem，此时我们将 relax_integrality 设置为 0，因为该 problem 仅接受整数解才有意义。

图 14-3 中的 for 循环用于创建初始切割模式，之后主 repeat 循环执行 Gilmore-Gomory 过程，如前所述。语句

solve Cutting_Opt;

将恢复 Cutting_Opt 作为当前 problem 及其环境，并求解相应的线性规划 (linear program)。然后赋值语句将 Cutting_Opt 的最优对偶价格传递给 Pattern_Gen 将使用的参数 price[i]。在 AMPL 中，所有集合和参数都是全局的，因此无论当前 problem 是什么，它们都可以被引用或修改。

主循环的后半部分切换到 problem Pattern_Gen 及其环境，并将相关的整数规划 (integer program) 发送给求解器 (solver)。如果得到的目标函数值足够负，则由 Use[i] 变量返回的模式将被添加到下一轮 Cutting_Opt 使用的数据中。否则无法继续优化，循环终止。

脚本最后通过以下语句求解使用所有生成模式的最佳整数解：

option Cutting_Opt.relax_integrality 0; solve Cutting_Opt;

表达式 Cutting_Opt.relax_integrality 表示在 Cutting_Opt 环境中 relax_integrality 选项的值。我们将在下一节更详细地讨论这类名称及其用途。

作为其工作方式的一个示例，图 14-4 显示了切割 110 英寸的原材料卷以满足宽度分别为 20、45、50、55 和 75 的成品卷的需求量 48、35、24、10 和 8 的数据。图 14-5 显示了当使用图 14-2 和图 14-4 所示的模型和数据运行图 14-3 的脚本时产生的输出。最优的分数解使用五种不同的模式切割 46.25 个原材料卷，如果将分数值向上取整到下一个整数，则需要 48 个卷。最终使用整数变量求解显示了如何应用六种模式的集合来仅使用 47 个原材料卷满足需求。

# 14.5 命名问题

正如我们的切割优化示例所示，编写在两个 (或多个) 模型之间交替的清晰高效脚本的关键在于使用命名问题，这些命名问题代表模型组件的不同子集。在本节中，我们将更详细地描述如何使用 AMPL 的问题语句来定义、使用和显示命名问题。最后我们还将介绍一个类似的概念，即命名环境，它有助于在 AMPL 选项集合之间切换。

本节中的图示取自切割优化脚本和 AMPL 网站上的一些其他示例脚本。这些脚本背后的逻辑解释超出了本书的范围；在本章末尾的参考文献中给出了一些进一步学习的建议。

# 定义命名问题

在 AMPL 会话的任何时候，都存在一个由变量、目标和约束列表组成的当前问题。默认情况下，当前问题被命名为 Initial，并且包含到目前为止定义的所有变量、目标和约束。然而，您可以定义其他由这些组件子集组成的 "命名" 问题，并使它们成为当前问题。当一个命名问题被设为当前问题时，问题子集中的所有模型组件都将被激活，而所有其他变量、目标和约束将被停用。更准确地说，问题子集中的变量将被解固定，其余变量将在其当前值处被固定。问题子集中的目标和约束将被恢复，其余的将被丢弃。 (固定和丢弃在第 11.4 节中讨论。)

您可以通过一个问题声明最直接地定义一个问题，该声明给出问题的名称及其组件列表。因此在图 14-3 中我们有：

```ampl
problem Cutting_Opt: Cut, Number, Fill;
```

定义了一个名为 Cutting_Opt 的新问题，该问题包含来自图 14-2 模型中的所有 Cut 变量、目标函数 Number 以及所有 Fill 约束。同时，Cutting_Opt 成为当前问题。任何固定的 Cut 变量将被解除固定，而所有其他已声明的变量则在其当前值处被固定。如果目标函数 Number 此前被删除，则会被恢复，而所有其他已声明的目标函数则被删除；同样地，任何被删除的 Fill 约束会被恢复，而所有其他已声明的约束则被删除。

对于更复杂的模型，一个问题的组成部分列表通常包括多个变量和约束集合，例如在 stochl.run (来自 AMPL 网站的一个示例) 中的这个例子：

```ampl
problem Sub: Make, Inv, Sell, Stage2_Profit, Time, Balance2, Balance;
```

通过在问题名称后指定索引表达式，你可以定义一个问题的索引集合，例如在 multi.2.run (另一个网站示例) 中的这些定义：

```ampl
problem SubII {p in PROD}: Reduced_Cost[p],
  {i in ORIG, j in DEST} Trans[i,j,p],
  {i in ORIG} Supply[i,p],
  {j in DEST} Demand[j,p];
```

对于集合 PROD 中的每一个 $\mathbb{P}$，都会定义一个 SubII[p] 问题。其组成部分包括目标函数 Reduced_Cost[p]、对于每个在 ORIG 中的 i 和在 DEST 中的 j 组合的变量 Trans[i,j,p]，以及对于每个在 ORIG 中的 i 的约束 Supply[i,p] 和对于每个在 DEST 中的 j 的约束 Demand[j,p]。

一个问题声明的形式和解释自然与其他指定模型组件列表的 AMPL 语句相似。声明以关键字 problem 开头，接着是一个之前未用于任何其他模型组件的问题名称、一个可选的索引表达式（用于定义一个问题的索引集合）和一个冒号。冒号后是用逗号分隔的变量、目标函数和约束列表，这些将被包含在问题中。该列表可以包含以下任意形式的条目，其中“component”指的是任何变量、目标函数或约束：

一个组件名称，例如 Cut 或 Fill，指的是所有具有该名称的组件。  
一个带下标的组件名称，例如 Reduced_Cost[p]，指的是该组件本身。  
一个索引表达式后跟一个带下标的组件名称，例如 {i in ORIG} Supply[i,p]，指的是索引集中每个成员的一个组件。

为了避免在多个组件以相同方式索引时重复索引表达式，问题语句也允许一个索引表达式后跟一个括号内的组件列表。例如，以下写法是等价的：

{i in ORIG} Supply1[i,p], {i in ORIG} Supply2[i,p], {i in ORIG, j in DEST} Trans[i,j,p], {i in ORIG, j in DEST} Use[i,j,p]  
{i in ORIG} (Supply1[i,p], Supply2[i,p], {j in DEST} (Trans[i,j,p], Use[i,j,p]))

正如这些示例所示，括号内的列表可以包含任何在组件列表中有效的项，甚至可以是一个索引表达式后跟另一个括号列表。这种递归形式也出现在 AMPL 的 print 命令中，但比 display 命令所允许的列表格式更通用。

每当声明一个变量、目标或约束时，它会自动被添加到当前问题（如果最近的问题语句指定了一个问题的索引集合，则添加到所有当前问题）中。因此，在我们的切割库存示例中，图 14-2 的所有模型组件默认首先被放入问题 Initial 中；然后，当运行图 14-3 的脚本时，通过使用 problem 语句将这些组件分配到问题 Cutting_Opt 和 Pattern_Gen 中。作为替代方案，我们可以声明空问题，然后通过 AMPL 声明填充其成员。图 14-6（cut2.mod）展示了如何为图 14-2 的模型完成这一操作。这种方法在较简单的应用中有时更为清晰或易于实现。

任何使用 drop/restore 或 fix/unfix 的操作也会修改当前问题。drop 命令的效果是从当前问题中移除约束或目标，而 restore 命令的效果是向当前问题中添加约束或目标。类似地，fix 命令从当前问题中移除变量，而 unfix 命令则添加变量。例如，multil.run 使用以下问题语句：

问题 Cutting_Opt;  
参数 nPAT integer $\geq 0$ default 0;  
参数 roll_width;  
集合 PATERNS $= 1$..nPAT;  
集合 WIDTHS;  
参数 orders {WIDTHS} $> 0$;  
参数 nbr {WIDTHS, PATERNS} integer $\geq 0$;  
check {j in PATERNS}: sum {i in WIDTHS} i \* nbr[i,j] $\leq$ roll_width;  
变量 Cut {PATERNS} $\geq 0$;  
最小化 Number: sum {j in PATERNS} Cut[j];  
约束 Fill {i in WIDTHS}: sum {j in PATERNS} nbr[i,j] \* Cut[j] $\geq$ orders[i];  

问题 Pattern_Gen;  
参数 price {WIDTHS};  
变量 Use {WIDTHS} integer $\geq 0$;  
最小化 Reduced_Cost: 1 - sum {i in WIDTHS} price[i] \* Use[i];  
约束 Width_Limit: sum {i in WIDTHS} i \* Use[i] $\leq$ roll_width;

用于定义其分解过程第一阶段和第二阶段的命名问题。相比之下，multila.run 最初指定问题如下：  
problem Master: Artificial, Weight, Excess, Multi, Convex;  
problem Sub: Artif_Reduced_Cost, Trans, Supply, Demand;  
以定义初始问题，然后在需要将问题转换为适用于第二阶段的形式时执行：  
problem Master;  
drop Artificial;  
restore Total_Cost;  
fix Excess;  
problem Sub;  
drop Artif_Reduced_Cost;  
restore Reduced_Cost;  

由于在整个过程中使用了名称 Master 和 Sub，因此脚本中的一个循环就足以实现两个阶段。

或者，一个重新声明的问题语句可以为一个问题提供新的定义。例如，上面的 drop、restore 和 fix 命令可以被替换为 redeclare problem Master: Total Cost, Weight, Multi, Convex; redeclare problem Sub: Reduced Cost, Trans, Supply, Demand;

然而，像其他声明一样，这不能在复合语句 (if、for 或 repeat) 内使用，因此不能在 multila.run 示例中使用。

reset 命令的一种形式允许您撤销对问题定义所做的任何更改。例如，reset problem Cutting_Opt; 将 Cutting_Opt 的定义重置为最近一次定义它的的问题语句中的组件列表。

# 使用命名问题

接下来我们描述更改当前问题的替代方法。任何更改通常会导致不同的目标和约束被丢弃，不同的变量被固定，结果是为求解器生成了不同的优化问题。然而，仅通过更改当前问题，不会影响与模型组件关联的值。所有先前声明的组件都是可访问的，无论当前问题是什么，它们都保持相同的值，除非它们被 let 或 data 语句显式更改，或者在变量和目标值及相关量 (如对偶值、栈和简化成本) 的情况下通过求解更改。

任何仅引用一个问题 (而不是问题的索引集合) 的问题语句都会使该问题成为当前问题。例如，在切割库存脚本的开始，我们希望先使一个命名问题成为当前问题，然后使另一个命名问题成为当前问题，以便我们可以在问题的环境中调整某些选项。cut1.run 中的问题语句 (图 14-3)：

问题 Cutting_Opt: Cut, Number, Fill; option relax_integrality 1; 问题 Pattern_Gen: Use, Reduced_Cost, Width_Limit; option relax_integrality 0; 既用于定义新问题，也用于使这些问题成为当前问题。cut2.run 中的类似语句更简单：

problem Cutting_Opt; option relax_integrality 1; problem Pattern_Gen; option relax_integrality 0;

这些语句仅用于使命名问题成为当前问题，因为问题已经由 cut2.mod 中的问题语句 (图 14-6) 定义。

问题语句也可以引用问题的索引集合，如之前引用的 multi2.run 示例：

problem SubII {p in PROD}: Reduced_Cost[p], ...

这种形式定义了潜在的许多问题，每个 PROD 集合的成员对应一个问题。后续的问题语句可以一次使集合的一个成员成为当前问题，如具有以下形式的循环 for {p in PROD} { problem SubII[p]; }

或在诸如 problem SubII["coils"] 的语句中引用特定成员。

正如之前的示例所示，solve 语句也可以包含一个问题名称，这种情况下命名的问题将变为当前问题，然后被发送到求解器。因此，诸如 solve Pattern_Gen 这样的语句的效果与先执行 problem Pattern_Gen 再执行 solve 的效果完全相同。

# 显示命名问题

仅由 problem 组成的命令用于显示当前问题：

mpl: model cut.mod;  
appl: data cut.dat;  
appl: problem;  
problem Initial;  
appl: problem Cutting_Opt: Cut, Number, Fill;  
appl: problem Pattern_Gen: Use, Reduced_Cost, Width_Limit;  
appl: problem;  
problem Pattern_Gen;

在定义其他命名问题之前，当前问题始终为 Initial。show 命令可以列出已定义的命名问题：

mpl: show problems;  
problems: Cutting_Opt Pattern_Gen

我们也可以使用 show 查看构成特定问题或索引问题集合的变量、目标和约束：

mpl: show Cutting_Opt, Pattern_Gen;  
problem Cutting_Opt: Fill, Number, Cut;  
problem Pattern_Gen: Width_Limit, Reduced_Cost, Use;

并使用 expand 查看当前问题在所有数据值被替换后的显式目标和约束：

mpl: expand Pattern_Gen;  
minimize Reduced Cost:  
 - 0.166667*Use[20] - 0.416667*Use[45] - 0.5*Use[50] - 0.5*Use[55] - 0.833333*Use[75] + 1;  
subject to Width_Limit:  
 20*Use[20] + 45*Use[45] + 50*Use[50] + 55*Use[55] + 75*Use[75] <= 110;

有关 show 和 expand 的进一步讨论，请参见第 12.6 节。

# 定义和使用命名环境

正如在 AMPL 会话的任何时刻都存在一个当前问题一样，也始终存在一个当前环境。问题是一组非固定变量以及未被丢弃的目标和约束，而环境则记录了所有 AMPL 选项的值。通过命名不同的环境，脚本可以轻松地在不同的选项设置集合之间切换。

在默认操作模式下 (该模式对于许多用途已经足够)，当前环境始终与当前问题同名。在 AMPL 会话开始时，当前环境被命名为 Initial，之后每当 problem 语句定义一个新的命名问题时，也会同时定义一个与该问题同名的新环境。环境在创建时会继承当时的所有选项设置，但在其作为当前环境时所做的新设置将被保留。任何更改当前问题的 problem 或 solve 语句也会切换到相应命名的环境，并相应地设置选项。

例如，我们用于切割库存问题的脚本 (图 14-3) 在设置模型和数据后，按如下方式继续执行：

option solver cplex, solution_round 6;  
option display_1col 0, display_transpose -10;  
problem Cutting_Opt: Cut, Number, Fill;  
option relax_integrality 1;  
problem Pattern_Gen: Use, Reduced_Cost, Width_Limit;  
option relax_integrality 0;

选项 `solver` 和其他三个选项 (由前两个选项语句修改) 在任何问题语句之前更改；因此，它们的新设置会被后续定义的环境继承，并且在脚本的其余部分中保持不变。接下来，一个问题语句定义了一个新问题和一个名为 `Cutting_Opt` 的新环境，并使其成为当前问题和环境。随后的选项语句将 `relax_integrality` 更改为 `1`。此后，当 `Cutting_Opt` 是脚本中的当前问题 (和环境) 时，`relax_integrality` 的值将是 `1`。最后，另一个问题和选项语句对问题 (和环境) `Pattern_Gen` 执行了类似操作，不同之处在于在该环境中 `relax_integrality` 被重新设置为 `0`。

这些初始语句的结果是确保在重复循环中的每个后续 `solve` 语句都能正确设置。`solve Cutting_Opt` 的结果是将当前环境设置为 `Cutting_Opt`，从而将 `relax_integrality` 设置为 `1`，并导致切割优化 (Cutting_Opt) 问题的线性松弛被求解。类似地，`solve Pattern_Gen` 的结果是导致图案生成 (Pattern_Gen) 问题作为整数规划问题被求解。我们也可以在循环内使用选项语句来切换 `relax_integrality` 的设置，但通过这种方法，我们使循环——脚本的关键部分——尽可能简单。

在更复杂的情况下，可以通过使用由关键字 `environ` 后跟名称组成的语句，独立于命名问题来声明命名环境：

```
environ Master;
```

环境拥有自己的命名空间。如果该名称之前未被用作环境名称，则将其定义为环境名称，并与当前所有选项值相关联。否则，该语句的效果是使该环境 (及其相关选项值) 成为当前环境。

通过在问题语句中的冒号前放置 `environ` 和环境名称，先前声明的环境也可以与新命名问题的声明相关联：

```
problem MasterII environ Master:
```

然后，每当关联的问题成为当前问题时，命名环境会自动成为当前环境。在这种情况下，会覆盖通常创建的与问题同名的环境。

通过在环境名称后放置 AMPL 索引表达式，可以在 `environ` 语句中声明环境的索引集合。然后，该名称以通常方式“下标”以引用各个环境。

命名环境以与命名问题相同的方式处理更改。如果在某个特定环境为当前环境时更改了某个选项的值，则会记录新值，并且当该环境再次成为当前环境时，将恢复该值。

# 参考文献

[1] Vasek Chvátal, 《Linear Programming》, Freeman, New York, NY, 1983.

[2] Marshall L. Fisher, “An Applications Oriented Guide to Lagrangian Relaxation”, 《Interfaces》, 15 卷第 2 期 (1985), 第 10–21 页。

[3] Robert Fourer 与 David M. Gay, “Experience with a Primal Presolve Algorithm”, 载于《Large Scale Optimization: State of the Art》, W. W. Hager、D. W. Hearn 和 P. M. Pardalos 编, Kluwer Academic Publishers, Dordrecht, The Netherlands, 1994, 第 135–154 页。

[4] Robert W. Haessler, “Selection and Design of Heuristic Procedures for Solving Roll Trim Problems”, 《Management Science》, 34 卷第 12 期 (1988), 第 1460–1471 页。

[5] Leon S. Lason, 《Optimization Theory for Large Systems》, Macmillan, New York, NY, 1970；后由 Dover 重印, Mineola, NY, 2002。
